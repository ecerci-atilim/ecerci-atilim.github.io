<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BCJR Trellis Visualizer & Path Exporter</title>
    <style>
        /* Basic Styling */
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding-bottom: 50px; }
        .controls { margin-bottom: 20px; padding: 15px; border: 1px solid #ccc; border-radius: 5px; background-color: #f9f9f9; display: flex; flex-wrap: wrap; align-items: center; gap: 15px; width: 90%; max-width: 800px; box-sizing: border-box;}
        .controls div { display: flex; align-items: center; }
        .controls label { margin-right: 5px; white-space: nowrap; }
        .controls input[type="number"] { width: 60px; padding: 3px; border: 1px solid #ccc; border-radius: 3px;}
        .controls button { padding: 5px 10px; cursor: pointer; border: 1px solid #aaa; border-radius: 3px; background-color: #eee;}
        .controls button:hover { background-color: #ddd; }
        .controls .generate-button { margin-left: auto; } /* Push generate button right */
        button:disabled { cursor: not-allowed; background-color: #f5f5f5; color: #aaa; }

        /* Trellis Container and SVG */
        #trellis-container { width: 95%; max-width: 1600px; margin-top: 20px; overflow-x: auto; border-bottom: 2px solid #eee; padding-bottom: 20px; margin-bottom: 20px; min-height: 50px; border: 1px dashed lightgray; }
        svg { display: block; margin: auto; border: 1px solid #eee; }
        .node { fill: lightblue; stroke: black; stroke-width: 1; transition: fill 0.2s ease; }
        .node:hover { fill: orange; }
        .node-start-end { fill: lightgreen; stroke-width: 2; stroke: darkgreen; }
        .state-label { font-size: 11px; text-anchor: end; dominant-baseline: middle; font-weight: normal; }
        .state-label-active { font-weight: bold; }
        .branch { stroke-width: 1.5; marker-end: url(#arrow); transition: stroke 0.2s ease, stroke-width 0.2s ease; }
        .branch:hover { stroke-width: 3; }
        .branch-0 { stroke: blue; }
        .branch-1 { stroke: red; stroke-dasharray: 4 2; }
        .branch-preamble, .branch-tail { stroke: purple; } /* Style for preamble/tail */
        .branch-label { font-size: 9px; text-anchor: middle; fill: gray; pointer-events: none; }
        .time-label { font-size: 10px; text-anchor: middle; fill: #555; }
        .phase-label { font-size: 12px; font-weight: bold; text-anchor: middle; fill: black; }

        /* Output Sections */
        #error-message { color: red; margin-top: 10px; font-weight: bold; width: 90%; text-align: center; min-height: 1.2em;}
        #paths-container { margin-top: 20px; width: 90%; max-width: 1000px; text-align: left; }
        #paths-list { font-family: monospace; font-size: 0.9em; white-space: pre-wrap; word-break: break-all; max-height: 400px; overflow-y: auto; border: 1px solid #ccc; padding: 10px; background-color: #fdfdfd; min-height: 30px; }
        #paths-list p { margin: 4px 0; line-height: 1.4; }
        .path-line { margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px dashed #eee; }
        .path-line:last-child { border-bottom: none; }
        .label { display: inline-block; width: 60px; }
        .download-section { margin-top: 15px; text-align: center; width: 90%; max-width: 1000px;}
    </style>
</head>
<body>

    <h1>BCJR Trellis Visualizer & Path Exporter</h1>
    <p>Models L preamble (0s) + N message + L tail (0s) symbols.</p>
    <p>Tau Rule: tau<sub>k</sub>(b<sub>k</sub>, b<sub>k-1</sub>) for k=2..K<sub>total</sub>. Peak: p<sub>k</sub> = p<sub>k-1</sub> + tau<sub>k</sub> * fs.</p>

    <!-- Ensure IDs here match getElementById calls -->
    <div class="controls">
        <div><label for="message-length">N (Msg Symbols):</label><input type="number" id="message-length" value="3" min="3" max="10"></div>
        <div><label for="memory-length">L (Memory/Preamble/Tail):</label><input type="number" id="memory-length" value="2" min="2" max="4"></div>
        <div><label for="initial-peak-loc">Peak Loc (p<sub>1</sub> - 1st Preamble):</label><input type="number" id="initial-peak-loc" value="0" step="any"></div>
        <button class="generate-button" onclick="generateTrellisAndPaths()">Generate Trellis & List Paths</button>
    </div>

    <div id="error-message"></div>
    <div id="trellis-container"><svg id="trellis-svg" width="1200" height="400" preserveAspectRatio="xMidYMid meet"></svg></div>
    <div id="paths-container">
        <h2>All Possible Paths (K<sub>total</sub> = L+N+L = <span id="total-symbols"></span> Input Symbols)</h2>
        <div id="paths-list">Click "Generate" to see paths...</div>
    </div>
    <div class="download-section">
         <button id="download-button" onclick="downloadPathInfo()" disabled>Download Path Info (JSON)</button>
    </div>

    <script>
        // Global variables to store data and parameters
        let allPaths = [];
        let currentN = 0;
        let currentL = 0;
        let currentP1 = 0;
        const fs = 10;
        console.log("Script loaded.");

        // Helper function to get state label
        function getStateLabel(stateIndex, L) {
            return stateIndex.toString(2).padStart(L, '0');
        }

        // --- DFS to find paths, input sequences, and taus ---
        // Calculates K_total taus (tau_1..tau_K_total) based on state transitions
        function findAllPathsDFS(k, currentState, currentPathStates, currentPathInputs, currentPathTaus, reachable, N, L, totalSteps) {
            currentPathStates.push(currentState); // Add s_k

            if (k === totalSteps) { // Reached final state s_{L+N+L}
                if (currentState === 0) {
                    allPaths.push({
                        states: [...currentPathStates], // Length K_total+1
                        inputs: [...currentPathInputs], // Length K_total
                        taus: [...currentPathTaus]      // Length K_total (tau_1..tau_K_total)
                    });
                }
                currentPathStates.pop(); return;
            }

            if (!(reachable[k + 1] instanceof Set)) { console.error(`DFS Error: reachable[${k + 1}] is not a Set at step k=${k}.`); currentPathStates.pop(); return; }

            // Determine input bit b_{k+1} based on phase
            let inputBit_b_k_plus_1;
            if (k < L) { inputBit_b_k_plus_1 = 0; } // Preamble
            else if (k < L + N) { /* Message phase handled below */ }
            else { inputBit_b_k_plus_1 = 0; } // Tail

            const possibleInputs = (k >= L && k < L + N) ? [0, 1] : [inputBit_b_k_plus_1];

            for (const inputBit of possibleInputs) { // inputBit is b_{k+1}
                const nextState = (currentState >> 1) | (inputBit << (L - 1)); // nextState is s_{k+1}

                if (reachable[k + 1].has(nextState)) {
                    const b_k = (currentState >> (L - 1)) & 1; // MSB of s_k
                    const tau_k_plus_1 = (inputBit === b_k) ? 0.6 : 0.9; // tau_{k+1}

                    currentPathInputs.push(inputBit);
                    currentPathTaus.push(tau_k_plus_1);
                    findAllPathsDFS(k + 1, nextState, currentPathStates, currentPathInputs, currentPathTaus, reachable, N, L, totalSteps);
                    currentPathInputs.pop();
                    currentPathTaus.pop();
                }
            }
            currentPathStates.pop();
        }

        // --- Main function to generate trellis and paths ---
        function generateTrellisAndPaths() {
            const downloadButton = document.getElementById('download-button');
            if(downloadButton) downloadButton.disabled = true;

            try {
                console.log("generateTrellisAndPaths called.");
                // 1. Get inputs, validate
                // Use global vars to store current parameters for download function
                currentN = parseInt(document.getElementById('message-length').value);
                currentL = parseInt(document.getElementById('memory-length').value);
                currentP1 = parseFloat(document.getElementById('initial-peak-loc').value);
                const errorMsg = document.getElementById('error-message');
                const svg = document.getElementById('trellis-svg');
                const pathsListDiv = document.getElementById('paths-list');
                const totalSymbolsSpan = document.getElementById('total-symbols');

                // Check if elements were found (crucial after fixing ID issues)
                if (!errorMsg || !svg || !pathsListDiv || !totalSymbolsSpan || !downloadButton) {
                     console.error("DOM Error: Could not find one or more required elements.");
                     alert("Error: Page elements missing. Cannot proceed.");
                     return;
                }
                console.log("DOM elements obtained.");
                svg.innerHTML = ''; pathsListDiv.innerHTML = 'Calculating...'; allPaths = []; errorMsg.textContent = '';
                console.log(`Inputs: N=${currentN}, L=${currentL}, p1_start=${currentP1}`);

                // Input Validation
                if (isNaN(currentN) || currentN < 3 || currentN > 10) { errorMsg.textContent = "Error: N must be between 3 and 10."; pathsListDiv.innerHTML = ''; console.error(errorMsg.textContent); return; }
                if (isNaN(currentL) || currentL < 2 || currentL > 4) { errorMsg.textContent = "Error: L must be between 2 and 4."; pathsListDiv.innerHTML = ''; console.error(errorMsg.textContent); return; }
                if (isNaN(currentP1)) { errorMsg.textContent = "Error: Peak Loc (p1) must be a number."; pathsListDiv.innerHTML = ''; console.error(errorMsg.textContent); return; }
                if (currentL >= 4 && currentN > 8) { errorMsg.textContent = "Warning: L+N+L large, may be slow."; }
                console.log("Input validation passed.");

                const totalInputSymbols = currentL + currentN + currentL; // K_total
                const totalSteps = totalInputSymbols;
                totalSymbolsSpan.textContent = totalInputSymbols;

                // 2. Trellis Parameters & SVG Setup
                const numStates = 1 << currentL;
                const nodeRadius = 8; const verticalPadding = 40; const horizontalPadding = 50;
                const stateLabelOffset = 30; const timeLabelOffset = 25;
                const svgHeight = (numStates * (nodeRadius * 2 + 15)) + 2 * verticalPadding + timeLabelOffset;
                const svgWidth = (totalSteps + 1) * (nodeRadius * 2 + 40) + 2 * horizontalPadding + stateLabelOffset;
                svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
                svg.setAttribute('width', '100%'); svg.setAttribute('height', svgHeight);
                const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
                defs.innerHTML = `<marker id="arrow" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse"><path d="M 0 0 L 10 5 L 0 10 z" fill="#888" /></marker>`;
                svg.appendChild(defs);
                console.log("SVG parameters set.");

                // 3. Calculate Node Positions
                const nodePositions = [];
                 for (let k_pos = 0; k_pos <= totalSteps; k_pos++) { nodePositions[k_pos] = []; const x = horizontalPadding + stateLabelOffset + k_pos * (svgWidth - 2 * horizontalPadding - stateLabelOffset) / totalSteps; for (let s = 0; s < numStates; s++) { const y = verticalPadding + (numStates === 1 ? (svgHeight - timeLabelOffset) / 2 : s * (svgHeight - 2 * verticalPadding - timeLabelOffset) / (numStates - 1)); if (isNaN(x) || isNaN(y)) { console.error(`Invalid node pos k=${k_pos}, s=${s}`); continue; } nodePositions[k_pos][s] = { x, y }; } }
                console.log("Node positions calculated.");

                // 4. Calculate Reachable States
                const reachable = Array(totalSteps + 1);
                reachable[0] = new Set([0]);
                console.log("Calculating reachable states...");
                 for (let k = 1; k <= totalSteps; k++) {
                    reachable[k] = new Set();
                    const inputBits = (k <= currentL) ? [0] : (k <= currentL + currentN) ? [0, 1] : [0];
                    if (reachable[k - 1] instanceof Set && reachable[k - 1].size > 0) {
                        for (const prevState of reachable[k - 1]) {
                             for (const inputBit of inputBits) {
                                const nextState = (prevState >> 1) | (inputBit << (currentL - 1));
                                const steps_remaining = totalSteps - k;
                                const max_val = (1 << steps_remaining);
                                if (nextState < max_val || (k === totalSteps && nextState === 0)) {
                                    reachable[k].add(nextState);
                                }
                            }
                        }
                    }
                    // Log only first step for brevity now
                    if (k === 1) { console.log(`>>> Calculated reachable[1]:`, reachable[1]); }
                }
                console.log("Reachable states calculation finished.");

                // 5. Sanity Check Termination
                 if (!reachable[totalSteps] || !reachable[totalSteps].has(0) || reachable[totalSteps].size !== 1) { console.warn(`Termination Check Warning: Reachable states at k=${totalSteps}:`, reachable[totalSteps]); /* ... set error message ... */ }
                 else { console.log("Termination check passed."); }

                // 6. Draw Trellis Elements
                console.log("Starting SVG drawing...");
                let svgElementsAdded = 0;
                // Draw State Labels
                for (let s_draw = 0; s_draw < numStates; s_draw++) { try { const label = getStateLabel(s_draw, currentL); const text = document.createElementNS("http://www.w3.org/2000/svg", "text"); const yPos = nodePositions[0]?.[s_draw]?.y; if (isNaN(yPos)) continue; text.setAttribute('x', horizontalPadding + stateLabelOffset - 15); text.setAttribute('y', yPos); text.setAttribute('class', 'state-label'); if (s_draw === 0) text.classList.add('state-label-active'); text.textContent = `${label} (${s_draw})`; svg.appendChild(text); svgElementsAdded++; } catch(e) { console.error("Error drawing state label:", e); }}
                // Draw Time Axis and Phase Labels
                const timeLabelY = svgHeight - verticalPadding / 2; if (!isNaN(timeLabelY)) { for (let k_draw = 0; k_draw <= totalSteps; k_draw++) { try { const xPos = nodePositions[k_draw]?.[0]?.x; if (isNaN(xPos)) continue; const timeLabel = document.createElementNS("http://www.w3.org/2000/svg", "text"); timeLabel.setAttribute('x', xPos); timeLabel.setAttribute('y', timeLabelY); timeLabel.setAttribute('class', 'time-label'); timeLabel.textContent = `k=${k_draw}`; svg.appendChild(timeLabel); svgElementsAdded++; } catch(e) { console.error("Error drawing time label:", e); }} }
                const phaseLabelY = timeLabelY + 15; if (!isNaN(phaseLabelY)) { if (currentL > 0) { const preamblePhaseLabel = document.createElementNS("http://www.w3.org/2000/svg", "text"); const preamblePhaseX = nodePositions[0]?.[0]?.x + (nodePositions[currentL]?.[0]?.x - nodePositions[0]?.[0]?.x) / 2; if(!isNaN(preamblePhaseX)) { preamblePhaseLabel.setAttribute('x', preamblePhaseX); preamblePhaseLabel.setAttribute('y', phaseLabelY); preamblePhaseLabel.setAttribute('class', 'phase-label'); preamblePhaseLabel.textContent = `Preamble (k=1..${currentL})`; svg.appendChild(preamblePhaseLabel); svgElementsAdded++; } } if (currentN > 0) { const msgPhaseLabel = document.createElementNS("http://www.w3.org/2000/svg", "text"); const msgPhaseX = nodePositions[currentL]?.[0]?.x + (nodePositions[currentL+currentN]?.[0]?.x - nodePositions[currentL]?.[0]?.x) / 2; if(!isNaN(msgPhaseX)) { msgPhaseLabel.setAttribute('x', msgPhaseX); msgPhaseLabel.setAttribute('y', phaseLabelY); msgPhaseLabel.setAttribute('class', 'phase-label'); msgPhaseLabel.textContent = `Message (k=${currentL+1}..${currentL+currentN})`; svg.appendChild(msgPhaseLabel); svgElementsAdded++; } } if (currentL > 0) { const tailPhaseLabel = document.createElementNS("http://www.w3.org/2000/svg", "text"); const tailPhaseX = nodePositions[currentL+currentN]?.[0]?.x + (nodePositions[currentL+currentN+currentL]?.[0]?.x - nodePositions[currentL+currentN]?.[0]?.x) / 2; if(!isNaN(tailPhaseX)) { tailPhaseLabel.setAttribute('x', tailPhaseX); tailPhaseLabel.setAttribute('y', phaseLabelY); tailPhaseLabel.setAttribute('class', 'phase-label'); tailPhaseLabel.textContent = `Tail (k=${currentL+currentN+1}..${totalSteps})`; svg.appendChild(tailPhaseLabel); svgElementsAdded++; } } }
                // Draw Branches
                for (let k_draw = 1; k_draw <= totalSteps; k_draw++) { if (!(reachable[k_draw-1] instanceof Set) || !(reachable[k_draw] instanceof Set)) { continue; } for (const prevState of reachable[k_draw - 1]) { const inputBits = (k_draw <= currentL) ? [0] : (k_draw <= currentL + currentN) ? [0, 1] : [0]; for (const inputBit of inputBits) { const nextState = (prevState >> 1) | (inputBit << (currentL - 1)); if (reachable[k_draw].has(nextState)) { try { const startPos = nodePositions[k_draw - 1]?.[prevState]; const endPos = nodePositions[k_draw]?.[nextState]; if (!startPos || !endPos || isNaN(startPos.x) || isNaN(startPos.y) || isNaN(endPos.x) || isNaN(endPos.y)) { continue; } const line = document.createElementNS("http://www.w3.org/2000/svg", "line"); line.setAttribute('x1', startPos.x); line.setAttribute('y1', startPos.y); line.setAttribute('x2', endPos.x); line.setAttribute('y2', endPos.y); let branchClass = `branch branch-${inputBit}`; if (k_draw <= currentL) { branchClass += ' branch-preamble'; } else if (k_draw > currentL + currentN) { branchClass += ' branch-tail'; } line.setAttribute('class', branchClass); svg.appendChild(line); svgElementsAdded++; const labelX = startPos.x + (endPos.x - startPos.x) * 0.5; const labelYOffset = (endPos.y - startPos.y) * 0.1; const labelY = startPos.y + (endPos.y - startPos.y) * 0.5 + (inputBit === 0 ? -5 : 5) - labelYOffset; if(!isNaN(labelX) && !isNaN(labelY)) { const branchLabel = document.createElementNS("http://www.w3.org/2000/svg", "text"); branchLabel.setAttribute('x', labelX); branchLabel.setAttribute('y', labelY); branchLabel.setAttribute('class', 'branch-label'); branchLabel.textContent = `${inputBit}`; svg.appendChild(branchLabel); svgElementsAdded++; } } catch(e) { console.error("Error drawing branch:", e); } } } } }
                 // Draw Nodes
                for (let k_draw = 0; k_draw <= totalSteps; k_draw++) { if (!(reachable[k_draw] instanceof Set)) { continue; } for (const s of reachable[k_draw]) { try { const pos = nodePositions[k_draw]?.[s]; if (!pos || isNaN(pos.x) || isNaN(pos.y)) { continue; } if (isNaN(nodeRadius) || nodeRadius <= 0) { continue; } const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle"); circle.setAttribute('cx', pos.x); circle.setAttribute('cy', pos.y); circle.setAttribute('r', nodeRadius); let nodeClass = 'node'; if ((k_draw === 0 || k_draw === totalSteps) && s === 0) { nodeClass += ' node-start-end'; } circle.setAttribute('class', nodeClass); svg.appendChild(circle); svgElementsAdded++; } catch(e) { console.error(`Error drawing node at k=${k_draw}, s=${s}:`, e); } } }
                console.log(`SVG drawing finished. Added approx ${svgElementsAdded} elements.`);
                console.log("SVG children count after drawing:", svg.children.length);


                // 7. Find All Paths, Inputs, and Tau Sequences using DFS
                 console.log("Calling DFS...");
                 findAllPathsDFS(0, 0, [], [], [], reachable, currentN, currentL, totalSteps);
                 console.log(`DFS finished. Found ${allPaths.length} paths.`);

                // 8. Calculate Peak Locations
                 console.log("Calculating peak locations...");
                 allPaths.forEach(pathData => { pathData.peakLocations = [currentP1]; let previousPeak = currentP1; for (let i = 1; i < pathData.taus.length; i++) { const tau_k = pathData.taus[i]; const currentPeak = previousPeak + tau_k * fs; pathData.peakLocations.push(parseFloat(currentPeak.toFixed(4))); previousPeak = currentPeak; } });
                 console.log("Peak locations calculated.");

                // 9. Format and Display Results
                 console.log("Updating display...");
                 let pathOutput = '';
                 try {
                     if (allPaths.length > 0) {
                         pathOutput = `Found ${allPaths.length} possible path(s):\n\n`;
                         allPaths.forEach((pathData, index) => {
                             const displayTaus = pathData.taus.slice(1); // tau_2 ... tau_K
                             pathOutput += `<div class="path-line">`;
                             pathOutput += `${(index + 1).toString().padStart(3, ' ')}:\n`;
                             pathOutput += ` <span class="label">Inputs:</span> [${pathData.inputs.join(', ')}]  (K<sub>total</sub> = ${totalInputSymbols} symbols: b<sub>1</sub>..b<sub>K</sub>)\n`;
                             pathOutput += ` <span class="label">States:</span> ${pathData.states.join(' -> ')}  (K<sub>total</sub>+1 = ${totalInputSymbols+1} states: s<sub>0</sub>..s<sub>K</sub>)\n`;
                             pathOutput += ` <span class="label">Taus:</span>   [${displayTaus.join(', ')}]  (K<sub>total</sub>-1 = ${totalInputSymbols-1} intervals: tau<sub>2</sub>..tau<sub>K</sub>)\n`;
                             pathOutput += ` <span class="label">Peaks:</span>  [${pathData.peakLocations.join(', ')}]  (K<sub>total</sub> = ${totalInputSymbols} locations: p<sub>1</sub>..p<sub>K</sub>)`;
                             pathOutput += `</div>`;
                         });
                         if(downloadButton) downloadButton.disabled = false;
                     } else {
                         pathOutput = "No valid paths found.";
                         console.log("No valid paths found by DFS.");
                         if(downloadButton) downloadButton.disabled = true;
                     }
                     pathsListDiv.innerHTML = pathOutput;
                     console.log("Display updated successfully.");

                 } catch (displayError) {
                     console.error("Error occurred during path formatting or display update:", displayError);
                     pathsListDiv.textContent = "Error displaying paths. Check console.";
                     if(downloadButton) downloadButton.disabled = true;
                 }

            } catch (error) {
                console.error("An unexpected error occurred in generateTrellisAndPaths:", error);
                const errorMsg = document.getElementById('error-message'); if(errorMsg) errorMsg.textContent = "An unexpected error occurred. Check console (F12).";
                const pathsListDiv = document.getElementById('paths-list'); if(pathsListDiv) pathsListDiv.innerHTML = '';
                const downloadButton = document.getElementById('download-button'); if(downloadButton) downloadButton.disabled = true;
            }
        } // End of generateTrellisAndPaths

        // --- Download Function ---
        function downloadPathInfo() {
            console.log("Download requested.");
            if (!allPaths || allPaths.length === 0) {
                alert("No path data available to download. Please generate paths first.");
                console.warn("Download attempted with no path data.");
                return;
            }

            // Create metadata object
            const metadata = {
                N: currentN,
                L: currentL,
                p1_start: currentP1,
                fs: fs,
                total_symbols_K: currentL + currentN + currentL,
                data_format: {
                    states: "s_0 to s_K (K+1 elements)",
                    inputs: "b_1 to b_K (K elements)",
                    // **** Updated Description ****
                    taus: "tau_2 to tau_K (K-1 elements)",
                    peakLocations: "p_1 to p_K (K elements)"
                }
            };

            // **** Create a modified paths array for export ****
            // This excludes the first tau (tau_1) from each path's tau list
            const exportPaths = allPaths.map(pathData => {
                return {
                    states: pathData.states,
                    inputs: pathData.inputs,
                    taus: pathData.taus.slice(1), // Exclude the first element (tau_1)
                    peakLocations: pathData.peakLocations
                };
            });
            console.log("Created modified paths array for export.");

            // Create the final object to be stringified using the modified paths
            const exportData = {
                metadata: metadata,
                paths: exportPaths // Use the modified array
            };

            // Convert the object to a JSON string with pretty printing
            let jsonString;
            try {
                 jsonString = JSON.stringify(exportData, null, 2); // Indent with 2 spaces
                 console.log("JSON string created, length:", jsonString.length);
            } catch (e) {
                console.error("Error stringifying data to JSON:", e);
                alert("Error creating JSON data for download.");
                return;
            }

            // Create a Blob
            const blob = new Blob([jsonString], { type: 'application/json' });
            console.log("Blob created, size:", blob.size);

            // Create a temporary URL
            const url = URL.createObjectURL(blob);
            console.log("Blob URL created:", url);

            // Create a temporary link element
            const link = document.createElement('a');
            link.href = url;
            link.download = `trellis_paths_N${currentN}_L${currentL}.json`;
            console.log("Download link created, filename:", link.download);

            // Append link to body (required for Firefox)
            document.body.appendChild(link);

            // Programmatically click the link to trigger download
            link.click();
            console.log("Link clicked.");

            // Clean up: remove link and revoke URL
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            console.log("Cleanup complete.");
        }

        console.log("Setting up window.onload.");
        window.onload = generateTrellisAndPaths;
        console.log("window.onload setup complete.");
    </script>

</body>
</html> 