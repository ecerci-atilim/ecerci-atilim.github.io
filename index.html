<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M-BCJR Trellis Diagram & Detector Simulation</title>
    <style>
        /* --- CSS Styles --- */
        body { font-family: Arial, sans-serif; margin: 20px; background-color: #f8f9fa; }
        .container { width: 100%; max-width: 100%; margin: 0 auto; background-color: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 20px; position: relative; }
        .controls { margin: 20px 0; padding: 15px; border-radius: 6px; background-color: #f8f9fa; display: flex; flex-wrap: wrap; justify-content: center; align-items: center; gap: 15px; }
        .control-group { display: flex; align-items: center; flex-wrap: wrap; gap: 5px 10px; }
        .diagram-container { overflow-x: auto; margin-top: 20px; border: 1px solid #e9ecef; border-radius: 6px; position: relative; width: 100%; min-height: 720px; }
        svg { display: block; margin: 0 auto; background-color: white; max-width: none; }
        .grid-line { stroke: #e9ecef; stroke-width: 1px; }
        .stage-separator { stroke: #dee2e6; stroke-width: 1px; stroke-dasharray: 5,3; }
        .state-circle { fill: white; stroke: #495057; stroke-width: 2px; cursor: pointer; filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.1)); transition: fill 0.2s ease-in-out, stroke-width 0.2s ease-in-out, stroke 0.2s ease-in-out; }
        .state-circle:hover { fill: #f0f0f0; }
        .state-text { text-anchor: middle; dominant-baseline: central; font-size: 14px; font-weight: 500; pointer-events: none; user-select: none; }
        .path-count { text-anchor: middle; font-size: 12px; font-weight: bold; fill: #007bff; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; dominant-baseline: auto; }
        .path-count.active { opacity: 1; }
        .sampling-time { text-anchor: middle; font-size: 12px; font-weight: bold; fill: #495057; pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; }
        .sampling-time.active { opacity: 1; }
        .transition { stroke-width: 1.5px; fill: none; transition: stroke 0.2s ease-in-out, stroke-width 0.2s ease-in-out, stroke-opacity 0.2s ease-in-out; }
        .transition-minus { stroke: #dc3545; }
        .transition-plus { stroke: #0d6efd; }
        .transition.inactive { stroke: #ced4da; stroke-width: 1px; stroke-opacity: 0.5; }
        .transition.highlight-path { stroke-width: 3.5px; stroke-opacity: 1; }
        .tau-label { text-anchor: middle; font-size: 14px; pointer-events: none; font-style: italic; font-weight: 500; opacity: 0; fill: #212529; filter: drop-shadow(0px 0px 1px white); transition: opacity 0.2s ease-in-out; }
         .tau-label-bg { pointer-events: none; opacity: 0; transition: opacity 0.2s ease-in-out; }
        .tau-label.active, .tau-label-bg.active { opacity: 1; }
        .highlighted-state { fill: #e9ecef; stroke-width: 3px; stroke: #0d6efd; }
        .stage-label { text-anchor: middle; font-size: 14px; fill: #495057; font-weight: 500; }
        .stage-number-label { text-anchor: middle; font-size: 11px; fill: #6c757d; font-weight: normal; }
        .checkbox-container { display: flex; align-items: center; cursor: pointer; }
        .checkbox-container input { cursor: pointer; margin-right: 6px; width: 16px; height: 16px; }
        .checkbox-label { font-weight: 600; color: #343a40; font-size: 14px; user-select: none; }
        label { font-weight: 600; color: #343a40; margin-right: 5px; }
        input[type=number], input[type=text] { padding: 8px; border: 1px solid #ced4da; border-radius: 4px; width: 80px; }
        button { padding: 8px 16px; background-color: #0d6efd; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; }
        button:hover { background-color: #0b5ed7; }
        .results-section { margin-top: 30px; padding: 20px; border: 1px solid #e9ecef; border-radius: 8px; background-color: #f8f9fa; }
        .results-section h2 { margin-top: 0; color: #343a40; border-bottom: 1px solid #dee2e6; padding-bottom: 10px; margin-bottom: 15px; }
        #llr-output pre { background-color: #fff; border: 1px solid #ddd; padding: 10px; border-radius: 4px; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 13px; white-space: pre-wrap; word-wrap: break-word; max-height: 200px; overflow-y: auto; }
        #plot-area { min-height: 200px; display: flex; justify-content: center; align-items: center; color: #6c757d; border: 0px dashed #ced4da; border-radius: 4px; margin-top: 15px; }
        #plot-area canvas { max-width: 100%; background-color: white; border: 1px solid #ddd; border-radius: 4px; }
         #formula-area { font-size: 14px; line-height: 1.6; margin-top: 15px; padding: 15px; background-color: #fff; border: 1px solid #ddd; border-radius: 4px; }
        .path-popup { position: absolute; background-color: white; border: 1px solid #ddd; border-radius: 8px; padding: 15px; width: 350px; max-height: 400px; overflow-y: auto; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; display: none; font-size: 13px; } .path-popup-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid #eee; padding-bottom: 5px; } .path-popup-title { font-weight: bold; font-size: 15px; color: #343a40; } .path-popup-close { background: none; border: none; font-size: 18px; cursor: pointer; color: #666; padding: 0 5px; } .path-popup-close:hover { color: #000; } .path-list { list-style: none; padding: 0; margin: 0; } .path-item { border-bottom: 1px solid #eee; padding: 8px 0; line-height: 1.4; } .path-item:last-child { border-bottom: none; } .path-info { font-size: 13px; color: #333; margin-bottom: 5px; } .path-transition { margin: 3px 0; padding-left: 15px; font-size: 12px; } .path-transition-minus { color: #dc3545; } .path-transition-plus { color: #0d6efd; } .path-sampling { margin-top: 8px; font-size: 13px; color: #6c757d; padding-left: 15px; } .sampling-highlight { font-weight: bold; color: #007bff; }
        @media (max-width: 768px) { .container { padding: 10px; } .controls { flex-direction: column; align-items: stretch; } .control-group { width: 100%; justify-content: flex-start; margin-bottom: 10px; } .control-group label { min-width: 140px; text-align: right; margin-right: 10px; } input[type=number], input[type=text] { width: calc(100% - 160px); min-width: 60px; } .state-circle { r: 20; } .state-text { font-size: 12px; } .path-popup { width: 90%; max-width: 350px; font-size: 12px; } .path-popup-title { font-size: 14px; } .path-info, .path-sampling { font-size: 12px; } .path-transition { font-size: 11px; } .results-section h2 { font-size: 18px; } #llr-output pre { font-size: 12px; } }
    </style>
    <!-- Include MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <!-- Include Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>M-BCJR Trellis Diagram & Detector Simulation</h1>
        <!-- Controls, Trellis, Results, Formulas sections as before -->
         <div class="controls"> <div class="control-group"> <label for="message-length">Message Length (N):</label> <input type="number" id="message-length" min="1" max="10" value="3"> </div> <div class="control-group"> <label for="memory-length">Memory Length (L):</label> <input type="number" id="memory-length" min="2" max="4" value="3"> </div> <div class="control-group" style="width: 100%; justify-content: center;"> <label for="binary-message" style="min-width: auto;">Binary Message (N bits):</label> <input type="text" id="binary-message" placeholder="e.g., 011" style="width: 200px; margin-right: 10px;"> <button id="random-message-button" type="button" style="padding: 8px 12px;">Random</button> </div> <div class="checkbox-container"> <input type="checkbox" id="extend-path" name="extend-path" style="vertical-align: middle;" checked> <label for="extend-path" class="checkbox-label">Show Extended Path</label> </div> <button id="generate-button">Generate Trellis & Simulate</button> </div>
         <div class="diagram-container"> <svg id="trellis-diagram"></svg> <div id="path-popup" class="path-popup"> <div class="path-popup-header"> <div class="path-popup-title">Path Information</div> <button id="close-popup" class="path-popup-close">&times;</button> </div> <div id="path-popup-content"></div> </div> </div>
         <div class="results-section"> <h2>Simulation Results (Noise-Free)</h2> <div id="llr-output"> <h3>Calculated LLRs:</h3> <pre>Run simulation to see LLRs...</pre> </div> <div id="plot-area"> <canvas id="rxSignalChart"></canvas> </div> </div>
         <div class="results-section"> <h2>Key Formulas</h2> <div id="formula-area"> Loading formulas... </div> </div>
    </div>

    <!-- **** START OF JAVASCRIPT **** -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Get UI Elements ---
            const generateButton = document.getElementById('generate-button');
            const extendPathCheckbox = document.getElementById('extend-path');
            const messageLengthInput = document.getElementById('message-length');
            const memoryLengthInput = document.getElementById('memory-length');
            const binaryMessageInput = document.getElementById('binary-message');
            const randomMessageButton = document.getElementById('random-message-button');
            const svg = document.getElementById('trellis-diagram');
            const diagramContainer = document.querySelector('.diagram-container');
            const popup = document.getElementById('path-popup');
            const popupContent = document.getElementById('path-popup-content');
            const closePopup = document.getElementById('close-popup');
            const llrOutputPre = document.querySelector('#llr-output pre');
            const plotArea = document.getElementById('plot-area');
            const formulaArea = document.getElementById('formula-area');
            let rxSignalCanvas = document.getElementById('rxSignalChart');

            // --- Global Variables & Constants ---
            let stateElements = {}; let transitionElements = []; let tauLabelElements = [];
            let samplingTimeElements = []; let pathCountElements = {}; let pathTracker = {};
            let transitionData = {}; let samplingTimes = {};
            let currentChart = null;
            const RRC_ALPHA = 0.3; const RRC_GDELAY = 4; const RRC_SPS = 10; let h_rrc = [];
            const LOG_ZERO = -Infinity; const COMPARE_TOLERANCE = 1e-6;
            let v_channel = []; // Store discrete channel response

            // --- Event Listeners ---
            generateButton.addEventListener('click', runFullSimulation);
            extendPathCheckbox.addEventListener('change', handleExtendPathChange);
            randomMessageButton.addEventListener('click', generateRandomMessage);
            messageLengthInput.addEventListener('input', () => { const N = parseInt(messageLengthInput.value) || 0; binaryMessageInput.placeholder = `Enter ${N} bits (0 or 1)`; });
            window.addEventListener('resize', adjustSvgSize);
            closePopup.addEventListener('click', () => popup.style.display = 'none');
            document.addEventListener('click', (event) => { if (!popup.contains(event.target) && !event.target.closest('.state-circle')) { popup.style.display = 'none'; resetHighlights(); } });

            // --- Main Function ---
            function runFullSimulation() {
                console.log("Starting Full Simulation...");
                llrOutputPre.textContent = "Running simulation...";
                if (currentChart) { currentChart.destroy(); currentChart = null; }
                plotArea.innerHTML = '<canvas id="rxSignalChart"></canvas>'; rxSignalCanvas = document.getElementById('rxSignalChart');
                if (!rxSignalCanvas) { console.error("Failed to find or recreate canvas!"); plotArea.textContent="Plotting Error"; return; }

                const N = parseInt(messageLengthInput.value);
                const L = parseInt(memoryLengthInput.value);
                if (isNaN(N) || N < 1 || isNaN(L) || L < 2 || L > 4) { alert("Please enter valid Message Length (N >= 1) and Memory Length (2 <= L <= 4)."); llrOutputPre.textContent = "Invalid Parameters."; plotArea.innerHTML = ''; return; }

                const trellisParams = generateTrellis(N, L);
                if (!trellisParams) { llrOutputPre.textContent = "Error generating trellis."; plotArea.innerHTML = ''; return; }

                const { binarySequence, modulatedSequence, tauSequence } = prepareTxSequence(N, L);
                if (!binarySequence) { llrOutputPre.textContent = "Invalid binary message input."; plotArea.innerHTML = ''; return; }
                console.log("Padded Modulated:", modulatedSequence); console.log("Tau Sequence:", tauSequence);

                if (h_rrc.length === 0) { h_rrc = rcosdesign_js(RRC_ALPHA, 2 * RRC_GDELAY, RRC_SPS, 'sqrt'); }
                if (h_rrc.length === 0) { alert("Error generating RRC filter."); llrOutputPre.textContent = "RRC Filter Error."; plotArea.innerHTML = ''; return; }
                const v = calculateDiscreteChannel(h_rrc);

                const upsampled = upsample(modulatedSequence, RRC_SPS);
                const txSignal = convolve(upsampled, h_rrc);
                const rxSignal = convolve(txSignal, h_rrc);
                console.log("Rx Signal r(t) generated, length:", rxSignal.length);

                // ****** Pass N to calculateSamples ******
                const { samplingInstants, sampledValuesYk } = calculateSamples(rxSignal, tauSequence, L, N);
                if (sampledValuesYk.some(isNaN) || sampledValuesYk.length !== L + N) { alert(`Error during sampling. Check console. Expected ${L+N} samples, got ${sampledValuesYk.length}.`); console.error("Sampling Instants:", samplingInstants); console.error("Sampled Yk:", sampledValuesYk); llrOutputPre.textContent = "Error during sampling."; plotArea.innerHTML = 'Plotting failed due to sampling error.'; return; }
                console.log("Sampled Values y_k:", sampledValuesYk);

                console.log("Calculating LogGamma matrices...");
                const logGammaMatrices = [null];
                for (let k = 1; k <= L + N; k++) { logGammaMatrices.push(calculateLogGammaMatrix(sampledValuesYk[k-1], k, v, trellisParams)); }
                console.log("LogGamma calculation complete.");

                const logAlpha = runForwardRecursion(logGammaMatrices, trellisParams, N);
                const logBeta = runBackwardRecursion(logGammaMatrices, trellisParams, N);
                const llrs = calculateLLRs(logAlpha, logBeta, logGammaMatrices, trellisParams, N);

                let llrText = `Calculated LLRs for Message Bits (Indices 0 to ${N-1}):\n`;
                let errors = 0;
                llrs.forEach((llr, index) => { const detectedBit = llr > 0 ? 0 : 1; const originalBit = binarySequence[index]; const isCorrect = detectedBit === originalBit; llrText += `Bit ${index}: LLR = ${llr.toFixed(4)} (Detect: ${detectedBit}, Orig: ${originalBit}) -> ${isCorrect ? "Correct" : "WRONG"}\n`; if (!isCorrect) errors++; });
                llrText += `\nTotal Message Bit Errors: ${errors}`;
                llrOutputPre.textContent = llrText;

                plotResults(rxSignalCanvas, rxSignal, samplingInstants, sampledValuesYk);
                displayFormulas();
                console.log("Full Simulation flow finished.");
            }

            // --- Trellis Generation (generateTrellis) ---
            function generateTrellis(messageLength, memoryLength) { /* ... Function code ... */
                console.log(`Generating trellis (N=${messageLength}, L=${memoryLength})...`);
                const samplingRate = RRC_SPS; const stateCount = 2 ** memoryLength; const totalStages = memoryLength + messageLength + memoryLength + 1;
                svg.innerHTML = ''; popup.style.display = 'none'; stateElements = {}; transitionElements = []; tauLabelElements = []; samplingTimeElements = []; pathCountElements = {}; pathTracker = {}; transitionData = {}; samplingTimes = {};
                const stageWidth = 120; const stateHeight = stateCount > 8 ? 60 : 70; const svgWidth = totalStages * stageWidth; const svgHeight = stateCount * stateHeight + 100;
                svg.setAttribute('width', svgWidth); svg.setAttribute('height', svgHeight); diagramContainer.style.minHeight = `${svgHeight + 20}px`;
                const reachableStates = Array(totalStages).fill().map(() => new Set()); reachableStates[0].add(0); samplingTimes[`s0_0`] = 0;
                for (let stage = 0; stage < totalStages - 1; stage++) { if (reachableStates[stage].size === 0) continue; for (const stateIdx of reachableStates[stage]) { const currentStateId = `s${stateIdx}_${stage}`; const currentTimes = samplingTimes[currentStateId]; if (currentTimes === undefined) continue; let timesToProcess = Array.isArray(currentTimes) ? currentTimes : [currentTimes]; let possibleInputs = []; if (stage < memoryLength) possibleInputs = [-1]; else if (stage >= memoryLength && stage < messageLength + memoryLength) possibleInputs = [-1, 1]; else possibleInputs = [-1]; const preFinalStateIdx = 2**(memoryLength - 1); if (stage === totalStages - 2) { if (stateIdx !== 0 && stateIdx !== preFinalStateIdx) possibleInputs = []; else possibleInputs = [-1]; } for (const input of possibleInputs) { let nextStateIdx; if (stage === totalStages - 2 && (stateIdx === 0 || stateIdx === preFinalStateIdx)) { nextStateIdx = 0; } else { const inputBit = (input + 1) / 2; nextStateIdx = ((stateIdx * 2) + inputBit) % stateCount; } reachableStates[stage + 1].add(nextStateIdx); const fromParity = stateIdx % 2; const toParity = nextStateIdx % 2; const tau = (fromParity === toParity) ? 0.6 : 0.9; const tauFactor = tau * samplingRate; const nextStateId = `s${nextStateIdx}_${stage + 1}`; const nextTimeIncrements = timesToProcess.map(ct => ct + tauFactor); if (!samplingTimes[nextStateId]) { samplingTimes[nextStateId] = nextTimeIncrements.length === 1 ? nextTimeIncrements[0] : [...new Set(nextTimeIncrements)].sort((a, b) => a - b); } else { let existingTimes = samplingTimes[nextStateId]; if (!Array.isArray(existingTimes)) existingTimes = [existingTimes]; const updatedTimes = [...new Set([...existingTimes, ...nextTimeIncrements])].sort((a, b) => a - b); samplingTimes[nextStateId] = updatedTimes.length === 1 ? updatedTimes[0] : updatedTimes; } } } }
                drawGridAndSeparators(svg, svgWidth, svgHeight, stateCount, stateHeight, totalStages, stageWidth); drawStates(svg, totalStages, reachableStates, stateHeight, stageWidth, samplingTimes); drawTransitions(svg, totalStages, reachableStates, stateHeight, stageWidth, messageLength, memoryLength, stateCount, samplingTimes, samplingRate); drawStageLabels(svg, totalStages, stageWidth, svgHeight, messageLength, memoryLength);
                adjustSvgSize(); console.log("Trellis generation complete."); return { totalStages, stateCount, memoryLength, reachableStates, transitionData, pathTracker };
             }

            // --- Input & Sequence Prep ---
            function generateRandomMessage() { /* ... Function code ... */
                  const N = parseInt(messageLengthInput.value) || 0; if (N < 1) { binaryMessageInput.value = ''; return; } let randomBits = ''; for (let i = 0; i < N; i++) { randomBits += Math.round(Math.random()); } binaryMessageInput.value = randomBits;
             }
            function prepareTxSequence(N, L) { /* ... Function code ... */
                 const binaryInput = binaryMessageInput.value.trim(); if (!/^[01]+$/.test(binaryInput) || binaryInput.length !== N) { alert(`Please enter exactly ${N} binary digits (0 or 1) for the message.`); return {}; } const messageBits = binaryInput.split('').map(Number); const padding = Array(L).fill(-1); const modulatedMessage = messageBits.map(bit => (bit === 0 ? 1 : -1)); const modulatedSequence = [...padding, ...modulatedMessage, ...padding]; const binaryPadding = Array(L).fill(1); const paddedSequence = [...binaryPadding, ...messageBits, ...binaryPadding]; const tauSequence = []; for (let i = 0; i < modulatedSequence.length - 1; i++) { if (modulatedSequence[i] * modulatedSequence[i+1] > 0) { tauSequence.push(0.6); } else { tauSequence.push(0.9); } } return { binarySequence: messageBits, paddedSequence, modulatedSequence, tauSequence };
             }

            // --- Signal Processing ---
            function rcosdesign_js(alpha, span, sps, shape) { /* ... Function code ... */ console.log(`rcosdesign_js: alpha=${alpha}, span=${span}, sps=${sps}, shape=${shape}`); const t = Array.from({ length: span * sps + 1 }, (_, i) => (i - span * sps / 2) / sps); const h = t.map(ti => { if (ti === 0) { return (1 / Math.sqrt(sps)) * (1 - alpha + 4 * alpha / Math.PI); } const term1Denom = Math.PI * ti * Math.sqrt(sps); const term2Denom = (4 * alpha * ti) ** 2 - 1; if (Math.abs(term2Denom) < 1e-8) { const val_at_singularity = (alpha / (Math.sqrt(2*sps))) * ((1 + 2 / Math.PI) * Math.sin(Math.PI / (4 * alpha)) + (1 - 2 / Math.PI) * Math.cos(Math.PI / (4 * alpha))); return val_at_singularity; } const term1 = Math.sin(Math.PI * ti * (1 - alpha)) / term1Denom; const term2 = (4 * alpha * ti / term1Denom) * Math.cos(Math.PI * ti * (1 + alpha)); return term1 + term2; }); if (shape === 'sqrt') { const energy = h.reduce((sum, val) => sum + val * val, 0); const normFactor = Math.sqrt(energy); if (normFactor > 1e-6) { return h.map(val => val / normFactor); } } return h; }
            function upsample(x, L) { /* ... Function code ... */ const y = []; x.forEach(val => { y.push(val); for (let i = 1; i < L; i++) { y.push(0); } }); return y; }
            function convolve(x, h) { /* ... Function code ... */ const N = x.length; const M = h.length; const yLen = N + M - 1; const y = new Array(yLen).fill(0); for (let n = 0; n < yLen; n++) { for (let k = 0; k < M; k++) { if (n - k >= 0 && n - k < N) { y[n] += h[k] * x[n - k]; } } } return y; }
            function calculateDiscreteChannel(h) { /* ... Function code ... */ console.log("Calculating discrete channel v = h * h..."); v_channel = convolve(h, h); const peak = Math.max(...v_channel.map(Math.abs)); console.log(`Discrete channel 'v' calculated, length: ${v_channel.length}, peak: ${peak}`); return v_channel; }
            // ****** UPDATED Signature ******
             function calculateSamples(rxSignal, tauSequence, L, N) { // Added N
                 /* ... Function code ... */
                 const samplingInstants = []; const sampledValuesYk = []; const peakOffset = RRC_GDELAY * 2 * RRC_SPS; let currentTimeIndex = peakOffset; samplingInstants.push(Math.round(currentTimeIndex)); for (let k = 0; k < L + N; k++) { if (k >= tauSequence.length) { console.warn(`Warning: Tau sequence shorter than required samples (k=${k}, tauLen=${tauSequence.length}). Using last tau.`); const lastTau = tauSequence.length > 0 ? tauSequence[tauSequence.length - 1] : 0.6; currentTimeIndex += lastTau * RRC_SPS; } else { currentTimeIndex += tauSequence[k] * RRC_SPS; } samplingInstants.push(Math.round(currentTimeIndex)); } const relevantInstants = samplingInstants.slice(1, L + N + 1); const relevantSamples = []; relevantInstants.forEach(idx => { if (idx >= 0 && idx < rxSignal.length) { relevantSamples.push(rxSignal[idx]); } else { console.warn(`Sampling index ${idx} out of bounds (rxSignal length ${rxSignal.length}). Pushing NaN.`); relevantSamples.push(NaN); } }); return { samplingInstants: relevantInstants, sampledValuesYk: relevantSamples };
             }

            // --- BCJR Core ---
            function calculateExpectedSample(prevStateIdx, input_ak, v, L, stateCount) { /* ... Function code ... */ const currentSymbol = input_ak; const prevSymbols = []; let tempState = prevStateIdx; for (let i = 0; i < L; i++) { const bit = tempState % 2; prevSymbols.push(bit === 0 ? 1 : -1); tempState = Math.floor(tempState / 2); } const symbolSequence = [...prevSymbols.reverse(), currentSymbol]; let expectedValue = 0; const vLen = v.length; const symLen = symbolSequence.length; const v_center_idx = Math.floor(vLen / 2); for (let k = 0; k < symLen; k++) { const v_idx = v_center_idx - (symLen - 1 - k); if (v_idx >= 0 && v_idx < vLen) { expectedValue += symbolSequence[k] * v[v_idx]; } } return expectedValue; }
            function logSumExp(log_terms) { /* ... Function code ... */ const filtered_terms = log_terms.filter(lt => lt > LOG_ZERO); if (filtered_terms.length === 0) return LOG_ZERO; const maxLog = Math.max(...filtered_terms); let sumExp = 0; for (const lt of filtered_terms) { sumExp += Math.exp(lt - maxLog); } return maxLog + Math.log(sumExp); }
            function calculateLogGammaMatrix(yk_n, stage_k, v, trellisParams) { /* ... Function code ... */ const { stateCount, memoryLength: L, reachableStates } = trellisParams; const logGamma_k = new Map(); const prevStageReachable = reachableStates[stage_k - 1]; if (!prevStageReachable) return logGamma_k; for (const prevStateIdx of prevStageReachable) { logGamma_k.set(prevStateIdx, new Map()); let possibleInputs = [-1, 1]; if ((stage_k -1) < L || (stage_k - 1) >= L + messageLengthInput.value) { possibleInputs = [-1]; } for (const input_ak of possibleInputs) { const inputBit = (input_ak + 1) / 2; const nextStateIdx = ((prevStateIdx * 2) + inputBit) % stateCount; if (reachableStates[stage_k]?.has(nextStateIdx)) { const lij = calculateExpectedSample(prevStateIdx, input_ak, v, L, stateCount); let logLikelihood = (Math.abs(yk_n - lij) < COMPARE_TOLERANCE) ? 0 : LOG_ZERO; const logGammaValue = logLikelihood; if (logGammaValue > LOG_ZERO) { logGamma_k.get(prevStateIdx).set(nextStateIdx, logGammaValue); } } } } return logGamma_k; }
            function runForwardRecursion(logGammaMatrices, trellisParams, N_msg) { /* ... Function code ... */ const { totalStages, stateCount, memoryLength: L } = trellisParams; const logAlpha = Array(totalStages).fill(null).map(() => new Map()); logAlpha[0].set(0, 0); for (let k = 1; k <= L + N_msg; k++) { const logGamma_k = logGammaMatrices[k]; if (!logGamma_k) continue; for (let currentStateIdx = 0; currentStateIdx < stateCount; currentStateIdx++) { const incomingTerms = []; for (const [prevStateIdx, nextStatesMap] of logGamma_k.entries()) { if (nextStatesMap.has(currentStateIdx)) { const logAlphaPrev = logAlpha[k - 1].get(prevStateIdx); if (logAlphaPrev !== undefined && logAlphaPrev > LOG_ZERO) { const logGammaVal = nextStatesMap.get(currentStateIdx); incomingTerms.push(logAlphaPrev + logGammaVal); } } } if (incomingTerms.length > 0) { const logAlpha_k_s = logSumExp(incomingTerms); if (logAlpha_k_s > LOG_ZERO) { logAlpha[k].set(currentStateIdx, logAlpha_k_s); } } } } console.log("Forward recursion (LogAlpha) complete."); return logAlpha; }
            function runBackwardRecursion(logGammaMatrices, trellisParams, N_msg) { /* ... Function code ... */ const { totalStages, stateCount, memoryLength: L } = trellisParams; const logBeta = Array(totalStages).fill(null).map(() => new Map()); const finalStageIndex = L + N_msg; logBeta[finalStageIndex].set(0, 0); for (let k = finalStageIndex - 1; k >= 0; k--) { const logGamma_k_plus_1 = logGammaMatrices[k + 1]; if (!logGamma_k_plus_1) continue; for (let currentStateIdx = 0; currentStateIdx < stateCount; currentStateIdx++) { const outgoingTerms = []; if (logGamma_k_plus_1.has(currentStateIdx)) { const nextStatesMap = logGamma_k_plus_1.get(currentStateIdx); for (const [nextStateIdx, logGammaVal] of nextStatesMap.entries()) { const logBetaNext = logBeta[k + 1].get(nextStateIdx); if (logBetaNext !== undefined && logBetaNext > LOG_ZERO) { outgoingTerms.push(logBetaNext + logGammaVal); } } } if (outgoingTerms.length > 0) { const logBeta_k_s = logSumExp(outgoingTerms); if (logBeta_k_s > LOG_ZERO) { logBeta[k].set(currentStateIdx, logBeta_k_s); } } } } console.log("Backward recursion (LogBeta) complete."); return logBeta; }
            function calculateLLRs(logAlpha, logBeta, logGammaMatrices, trellisParams, N_msg) { /* ... Function code ... */ const { stateCount, memoryLength: L } = trellisParams; const llrs = []; for (let k = L; k < L + N_msg; k++) { const logGamma_k_plus_1 = logGammaMatrices[k + 1]; let numeratorTerms = []; let denominatorTerms = []; if (!logGamma_k_plus_1) { llrs.push(0); continue; } for (const [prevStateIdx, nextStatesMap] of logGamma_k_plus_1.entries()) { const logAlphaPrev = logAlpha[k]?.get(prevStateIdx); if (logAlphaPrev === undefined || logAlphaPrev <= LOG_ZERO) continue; for (const [nextStateIdx, logGammaVal] of nextStatesMap.entries()) { const logBetaNext = logBeta[k + 1]?.get(nextStateIdx); if (logBetaNext === undefined || logBetaNext <= LOG_ZERO) continue; const term = logAlphaPrev + logGammaVal + logBetaNext; const inputBit0_nextState = (prevStateIdx * 2 + 0) % stateCount; const inputBit1_nextState = (prevStateIdx * 2 + 1) % stateCount; if (nextStateIdx === inputBit0_nextState) { numeratorTerms.push(term); } if (nextStateIdx === inputBit1_nextState) { denominatorTerms.push(term); } } } const logNumerator = logSumExp(numeratorTerms); const logDenominator = logSumExp(denominatorTerms); let llr = 0; if (logNumerator > LOG_ZERO && logDenominator > LOG_ZERO) { llr = logNumerator - logDenominator; } else if (logNumerator > LOG_ZERO) { llr = 100; } else if (logDenominator > LOG_ZERO) { llr = -100; } llrs.push(llr); } console.log("LLR calculation complete."); return llrs; }

            // --- Plotting ---
            function plotResults(canvasElement, rxSignal, samplingInstants, sampledValuesYk) { /* ... Function code ... */ console.log("Plotting results..."); if (!canvasElement) { console.error("Canvas element not provided for plotting."); return; } const ctx = canvasElement.getContext('2d'); if (!ctx) { console.error("Failed to get canvas context."); return; } const timeIndices = Array.from({ length: rxSignal.length }, (_, i) => i); const sampleData = samplingInstants.map((inst, i) => ({ x: inst, y: sampledValuesYk[i] })); if (currentChart) { currentChart.destroy(); } currentChart = new Chart(ctx, { type: 'line', data: { labels: timeIndices, datasets: [ { label: 'Received Signal r(t)', data: rxSignal, borderColor: 'rgb(75, 192, 192)', tension: 0.1, pointRadius: 0, borderWidth: 1.5 }, { label: 'Sampled Points y_k', data: sampleData, type: 'scatter', backgroundColor: 'rgb(255, 99, 132)', pointRadius: 4, pointHoverRadius: 6, showLine: false } ] }, options: { responsive: true, maintainAspectRatio: false, interaction: { mode: 'index', intersect: false, }, plugins: { title: { display: true, text: 'Noise-Free Received Signal and Sample Points' }, tooltip: { callbacks: { label: function(context) { let label = context.dataset.label || ''; if (label) { label += ': '; } if (context.parsed.y !== null) { if (context.dataset.type === 'scatter') { label += `(Index: ${context.parsed.x}, Value: ${context.parsed.y.toFixed(4)})`; } else { label += `Value: ${context.parsed.y.toFixed(4)}`; } } return label; } } } }, scales: { x: { title: { display: true, text: 'Sample Index' }, beginAtZero: true }, y: { title: { display: true, text: 'Amplitude' } } } } }); console.log("Chart created."); }

            // --- Formula Display ---
            function displayFormulas() { /* ... Function code ... */ formulaArea.innerHTML = `<h4>Signal Model:</h4> \\( s(t) = \\sum_n a_n h(t - n T_\\tau) \\) (conceptual, actual is conv(upsample(a), h)) <br> \\( r(t) = (s * h)(t) \\) (Noise-free received signal) <br> \\( y_k = r(t_k) \\) (Sampling at variable times \\( t_k \\)) <br> where \\( t_k = t_{k-1} + \\tau_{k-1} T_s \\) and \\( \\tau \\in \\{0.6, 0.9 \\} \\), \\(T_s = \\) ${RRC_SPS} <h4>Branch Metric (Log Domain, Noise-Free):</h4> \\( \\log \\gamma_k(s', s) = \\begin{cases} 0 & \\text{if } |y_k - l_{s',s}| < \\epsilon \\\\ -\\infty & \\text{otherwise} \\end{cases} \\) <br> where \\( l_{s',s} \\) is the expected noise-free sample for transition \\( s' \\to s \\). <h4>Forward Recursion (Log Domain):</h4> \\( \\log \\alpha_k(s) = \\underset{s'}{\\mathrm{logsumexp}} (\\log \\alpha_{k-1}(s') + \\log \\gamma_k(s', s)) \\) <h4>Backward Recursion (Log Domain):</h4> \\( \\log \\beta_k(s) = \\underset{s''}{\\mathrm{logsumexp}} (\\log \\beta_{k+1}(s'') + \\log \\gamma_{k+1}(s, s'')) \\) <h4>LLR Calculation:</h4> \\( LLR(a_k) = \\log \\frac{P(a_k=+1 | \\mathbf{y})}{P(a_k=-1 | \\mathbf{y})} \\) <br> \\( = \\log \\frac{\\sum_{(s',s): a_k=+1} \\exp(\\log \\alpha_{k-1}(s') + \\log \\gamma_k(s', s) + \\log \\beta_k(s))}{\\sum_{(s',s): a_k=-1} \\exp(\\log \\alpha_{k-1}(s') + \\log \\gamma_k(s', s) + \\log \\beta_k(s))} \\) `; if (window.MathJax && window.MathJax.typeset) { window.MathJax.typeset([formulaArea]); } }

            // --- Drawing/Interaction Helpers ---
            function drawGridAndSeparators(svg, svgWidth, svgHeight, stateCount, stateHeight, totalStages, stageWidth) { /* ... */ const drawingAreaHeight = svgHeight - 60; for (let i = 0; i <= stateCount; i++) { const y = i * stateHeight + 10; createLine(svg, 0, y, svgWidth, y, 'grid-line'); } for (let i = 0; i <= totalStages; i++) { const x = i * stageWidth; createLine(svg, x, 0, x, drawingAreaHeight, 'stage-separator'); } }
            function drawStates(svg, totalStages, reachableStates, stateHeight, stageWidth, currentSamplingTimes) { /* ... */ for (let stage = 0; stage < totalStages; stage++) { for (const stateIdx of reachableStates[stage]) { const x = 60 + stage * stageWidth; const y = 40 + stateIdx * stateHeight; const stateId = `s${stateIdx}_${stage}`; const stateCircle = createCircle(svg, x, y, 25, 'state-circle'); stateCircle.setAttribute('data-state-id', stateId); stateElements[stateId] = stateCircle; createText(svg, x, y, `s${stateIdx}`, 'state-text'); const timeValues = currentSamplingTimes[stateId]; if (timeValues !== undefined) { const displayTime = formatTimeValue(timeValues); const timeText = createText(svg, x, y + 38, displayTime, 'sampling-time'); timeText.setAttribute('data-state-id', stateId); samplingTimeElements.push(timeText); } const pathCountY = y - 30; const pathCountText = createText(svg, x, pathCountY, '', 'path-count'); pathCountText.setAttribute('data-state-id', stateId); pathCountElements[stateId] = pathCountText; stateCircle.addEventListener('mouseover', () => highlightConnections(stateId, extendPathCheckbox.checked)); stateCircle.addEventListener('mouseout', resetHighlights); stateCircle.addEventListener('click', (event) => { showPathPopup(stateId, event); event.stopPropagation(); }); } } }
            function formatTimeValue(timeValues) { /* ... */ if (Array.isArray(timeValues)) return [...new Set(timeValues)].sort((a, b) => a - b).join(', '); else return `${timeValues}`; }
            function drawTransitions(svg, totalStages, reachableStates, stateHeight, stageWidth, messageLength, memoryLength, stateCount, currentSamplingTimes, samplingRate) { /* ... */ for (let stage = 0; stage < totalStages - 1; stage++) { if (reachableStates[stage].size === 0) continue; for (const stateIdx of reachableStates[stage]) { const x1 = 60 + stage * stageWidth; const y1 = 40 + stateIdx * stateHeight; const fromStateId = `s${stateIdx}_${stage}`; const fromTimes = currentSamplingTimes[fromStateId]; if (fromTimes === undefined) continue; let possibleInputs = []; if (stage < memoryLength) possibleInputs = [-1]; else if (stage >= memoryLength && stage < messageLength + memoryLength) possibleInputs = [-1, 1]; else possibleInputs = [-1]; const preFinalStateIdx = 2**(memoryLength - 1); if (stage === totalStages - 2) { if (stateIdx !== 0 && stateIdx !== preFinalStateIdx) possibleInputs = []; else possibleInputs = [-1]; } for (const input of possibleInputs) { let nextStateIdx; if (stage === totalStages - 2 && (stateIdx === 0 || stateIdx === preFinalStateIdx)) { nextStateIdx = 0; } else { const inputBit = (input + 1) / 2; nextStateIdx = ((stateIdx * 2) + inputBit) % stateCount; } if (!reachableStates[stage + 1].has(nextStateIdx)) continue; const toStateId = `s${nextStateIdx}_${stage + 1}`; const x2 = 60 + (stage + 1) * stageWidth; const y2 = 40 + nextStateIdx * stateHeight; const toTimes = currentSamplingTimes[toStateId]; if (toTimes === undefined) continue; const fromParity = stateIdx % 2; const toParity = nextStateIdx % 2; const tau = (fromParity === toParity) ? 0.6 : 0.9; const transitionKey = `${fromStateId}__${toStateId}__${input}`; transitionData[transitionKey] = { from: fromStateId, to: toStateId, input: input, tau: tau, fromTimes: Array.isArray(fromTimes) ? fromTimes : [fromTimes], toTimes: Array.isArray(toTimes) ? toTimes : [toTimes] }; if (!pathTracker[toStateId]) pathTracker[toStateId] = []; pathTracker[toStateId].push({ from: fromStateId, input: input, tau: tau, key: transitionKey }); const path = createPath(svg, `M ${x1 + 25} ${y1} L ${x2 - 25} ${y2}`); path.setAttribute('class', input === -1 ? 'transition transition-minus' : 'transition transition-plus'); path.setAttribute('data-from', fromStateId); path.setAttribute('data-to', toStateId); path.setAttribute('data-input', input); transitionElements.push(path); const midX = (x1 + x2) / 2; const midY = (y1 + y2) / 2; const tauYOffset = 10; const tauTextContent = `τ=${tau}`; const tauLabel = createText(svg, midX, midY + tauYOffset, tauTextContent, 'tau-label'); tauLabel.setAttribute('data-from', fromStateId); tauLabel.setAttribute('data-to', toStateId); const textMetrics = estimateTextBBox(tauTextContent, 14); const labelWidth = textMetrics.width + 10; const labelHeight = textMetrics.height + 4; const bgRect = createRect(svg, midX - labelWidth / 2, midY + tauYOffset - labelHeight / 2 - 2, labelWidth, labelHeight, 4); bgRect.setAttribute('fill', 'rgba(255, 255, 255, 0.85)'); bgRect.setAttribute('class', 'tau-label-bg'); bgRect.setAttribute('data-from', fromStateId); bgRect.setAttribute('data-to', toStateId); svg.insertBefore(bgRect, tauLabel); tauLabelElements.push({ bg: bgRect, text: tauLabel }); } } } }
            function estimateTextBBox(text, fontSize) { /* ... */ const avgCharWidth = fontSize * 0.6; const height = fontSize * 1.2; return { width: text.length * avgCharWidth, height: height }; }
            function drawStageLabels(svg, totalStages, stageWidth, svgHeight, messageLength, memoryLength) { /* ... */ const labelY = svgHeight - 35; const stageNumberY = labelY + 16; for (let stage = 0; stage < totalStages -1 ; stage++) { const labelX = 60 + stage * stageWidth + stageWidth / 2; let labelContent = ''; if (stage < memoryLength) labelContent = `Init ${stage + 1}`; else if (stage < messageLength + memoryLength) labelContent = `Msg ${stage - memoryLength + 1}`; else if (stage < totalStages - 1) labelContent = `End ${stage - (messageLength + memoryLength) + 1}`; if (labelContent) { createText(svg, labelX, labelY, labelContent, 'stage-label'); createText(svg, labelX, stageNumberY, `${stage}`, 'stage-number-label'); } } }
            function createSvgElement(tag, attributes = {}, textContent = '') { /* ... */ const el = document.createElementNS('http://www.w3.org/2000/svg', tag); for (const key in attributes) { el.setAttribute(key, attributes[key]); } if (textContent) { el.textContent = textContent; } return el; }
            function createLine(svg, x1, y1, x2, y2, className) { /* ... */ const line = createSvgElement('line', { x1, y1, x2, y2, class: className }); svg.appendChild(line); return line; }
            function createCircle(svg, cx, cy, r, className) { /* ... */ const circle = createSvgElement('circle', { cx, cy, r, class: className }); svg.appendChild(circle); return circle; }
            function createText(svg, x, y, text, className) { /* ... */ const textEl = createSvgElement('text', { x, y, class: className }, text); svg.appendChild(textEl); return textEl; }
            function createPath(svg, d) { /* ... */ const path = createSvgElement('path', { d }); svg.appendChild(path); return path; }
            function createRect(svg, x, y, width, height, rx) { /* ... */ const rect = createSvgElement('rect', { x, y, width, height, rx }); svg.appendChild(rect); return rect; }
            function handleExtendPathChange() { /* ... */ const highlighted = document.querySelector('.state-circle.highlighted-state'); if (highlighted) { const stateId = highlighted.getAttribute('data-state-id'); highlightConnections(stateId, this.checked); } else { resetHighlights(); } }
            function highlightConnections(stateId, extendPath) { /* ... */ resetHighlights(); transitionElements.forEach(el => el.classList.add('inactive')); if (!stateElements[stateId]) return; stateElements[stateId].classList.add('highlighted-state'); activateElement(samplingTimeElements.find(el => el.getAttribute('data-state-id') === stateId)); if (extendPath) { const paths = findPathsToStart(stateId); const pathStates = new Set(); const pathTransitions = new Set(); if (paths.length > 0) { activateElement(pathCountElements[stateId], `${paths.length} path${paths.length > 1 ? 's' : ''}`); paths.forEach(path => { pathStates.add(path.states[0]); for (let i = 0; i < path.transitions.length; i++) { const trans = path.transitions[i]; const from = trans.from; pathStates.add(from); pathTransitions.add(trans.key || `${from}__${trans.to}__${trans.input}`); } }); pathStates.forEach(sId => { if (stateElements[sId]) stateElements[sId].classList.add('highlighted-state'); activateElement(samplingTimeElements.find(el => el.getAttribute('data-state-id') === sId)); if (sId !== stateId && sId !== 's0_0') { const iPaths = findPathsToStart(sId); if (iPaths.length > 0) activateElement(pathCountElements[sId], `${iPaths.length} path${iPaths.length > 1 ? 's' : ''}`); } }); transitionElements.forEach(transEl => { const from = transEl.getAttribute('data-from'); const to = transEl.getAttribute('data-to'); const input = transEl.getAttribute('data-input'); const key = `${from}__${to}__${input}`; if (pathTransitions.has(key)) { transEl.classList.remove('inactive'); transEl.classList.add('highlight-path'); activateElement(tauLabelElements.find(t => t.text.getAttribute('data-from') === from && t.text.getAttribute('data-to') === to)); } }); } else { activateElement(pathCountElements[stateId], "0 paths"); } } else { if (pathTracker[stateId]) { pathTracker[stateId].forEach(prev => { const fromId = prev.from; const input = prev.input; if (stateElements[fromId]) stateElements[fromId].classList.add('highlighted-state'); activateElement(samplingTimeElements.find(el => el.getAttribute('data-state-id') === fromId)); const transEl = transitionElements.find(t => t.getAttribute('data-from') === fromId && t.getAttribute('data-to') === stateId && t.getAttribute('data-input') == input); if (transEl) transEl.classList.remove('inactive'); activateElement(tauLabelElements.find(t => t.text.getAttribute('data-from') === fromId && t.text.getAttribute('data-to') === stateId)); }); } transitionElements.forEach(transEl => { if (transEl.getAttribute('data-from') === stateId) { transEl.classList.remove('inactive'); const toId = transEl.getAttribute('data-to'); const input = transEl.getAttribute('data-input'); if (stateElements[toId]) stateElements[toId].classList.add('highlighted-state'); activateElement(samplingTimeElements.find(el => el.getAttribute('data-state-id') === toId)); activateElement(tauLabelElements.find(t => t.text.getAttribute('data-from') === stateId && t.text.getAttribute('data-to') === toId)); } }); } }
            function activateElement(element, textContent = null) { /* ... */ if (!element) return; if (element.bg && element.text && element.bg.classList && element.text.classList) { element.bg.classList.add('active'); element.text.classList.add('active'); } else if (element.classList) { element.classList.add('active'); if (textContent !== null && element.textContent !== undefined) { element.textContent = textContent; } } else { console.warn("Attempted to activate an invalid element:", element); } }
            function resetHighlights() { /* ... */ Object.values(stateElements).forEach(el => el.classList.remove('highlighted-state')); transitionElements.forEach(el => { el.classList.remove('inactive'); el.classList.remove('highlight-path'); }); tauLabelElements.forEach(el => { if (el.bg && el.text) { el.bg.classList.remove('active'); el.text.classList.remove('active'); } }); samplingTimeElements.forEach(el => el.classList.remove('active')); Object.values(pathCountElements).forEach(el => { if (el) { el.classList.remove('active'); el.textContent = ''; } }); }
            function findPathsToStart(endStateId) { /* ... */ const foundPaths = []; const maxDepth = 50; function traversePath(currentId, currentPathStates, currentPathTransitions, depth) { if (depth > maxDepth) return; if (currentId === 's0_0') { const finalPathStates = [currentId, ...currentPathStates]; const finalTransitions = currentPathTransitions.slice().reverse(); const samplingSequence = [0]; finalTransitions.forEach(trans => { const transDetail = transitionData[trans.key]; let time = '?'; if(transDetail && transDetail.toTimes){ time = Array.isArray(transDetail.toTimes) ? transDetail.toTimes[0] : transDetail.toTimes; } samplingSequence.push(time); }); foundPaths.push({ states: finalPathStates, transitions: finalTransitions, samplingTimes: samplingSequence }); return; } const incoming = pathTracker[currentId]; if (incoming) { for (const prev of incoming) { const fromId = prev.from; const transInfo = { from: fromId, to: currentId, input: prev.input, tau: prev.tau, key: prev.key }; traversePath(fromId, [currentId, ...currentPathStates], [transInfo, ...currentPathTransitions], depth + 1); } } } traversePath(endStateId, [], [], 0); return foundPaths; }
            function showPathPopup(stateId, event) { /* ... */ const paths = findPathsToStart(stateId); const stateCoords = stateId.split('_'); const stateName = stateCoords[0]; const stageNum = stateCoords[1]; popupContent.innerHTML = ''; if (paths.length === 0) { popupContent.innerHTML = `<div>No paths found from state ${stateName} (Stage ${stageNum}) back to the start (s0 Stage 0).</div>`; } else { let html = `<div style="margin-bottom: 10px;">Found <strong>${paths.length}</strong> path${paths.length > 1 ? 's' : ''} from state <strong>${stateName} (Stage ${stageNum})</strong> to the start:</div><ul class="path-list">`; paths.forEach((path, index) => { const stateSequence = path.states.map(s => { const parts = s.split('_'); return `${parts[0]}(${parts[1]})`; }).join(' → '); const samplingSequence = path.samplingTimes.join(' → '); html += `<li class="path-item"><div class="path-info"><strong>Path ${index + 1}</strong>: ${stateSequence}</div><div class="path-sampling"><strong>Relative Sampling Increments:</strong> ${samplingSequence}</div><div style="margin-top: 5px; padding-left: 15px; font-size: 12px; color: #555;"><strong>Transitions:</strong></div>`; path.transitions.forEach((trans, tIndex) => { const inputClass = trans.input === -1 ? 'path-transition-minus' : 'path-transition-plus'; const fromState = path.states[tIndex].split('_')[0]; const toState = path.states[tIndex+1].split('_')[0]; const fromTime = path.samplingTimes[tIndex]; const toTime = path.samplingTimes[tIndex+1]; html += `<div class="path-transition ${inputClass}">${fromState}(${tIndex}) → ${toState}(${tIndex+1}) (In: ${trans.input === 1 ? '+1' : '-1'}, τ=${trans.tau}, <span class="sampling-highlight">${fromTime}→${toTime}</span>)</div>`; }); html += '</li>'; }); html += '</ul>'; popupContent.innerHTML = html; } const clickRect = event.target.getBoundingClientRect(); const containerRect = diagramContainer.getBoundingClientRect(); const popupWidth = popup.offsetWidth; const popupHeight = popup.offsetHeight; const viewportWidth = window.innerWidth; const viewportHeight = window.innerHeight; const scrollX = diagramContainer.scrollLeft; const scrollY = window.scrollY; let left = (clickRect.right - containerRect.left + scrollX) + 15; let top = (clickRect.top - containerRect.top + scrollY) + 5; if (left + popupWidth > viewportWidth + scrollX - 20) left = (clickRect.left - containerRect.left + scrollX) - popupWidth - 15; if (left < scrollX + 10) left = scrollX + 10; if (top + popupHeight > viewportHeight + scrollY - 20) top = (clickRect.bottom - containerRect.top + scrollY) - popupHeight - 15; if (top < scrollY + 10) top = scrollY + 10; popup.style.left = `${left}px`; popup.style.top = `${top}px`; popup.style.display = 'block'; }
            function adjustSvgSize() { /* ... */ svg.style.transform = 'none'; svg.style.transformOrigin = '0 0'; diagramContainer.style.height = 'auto'; const svgHeight = parseFloat(svg.getAttribute('height')); }

            // --- Initial Setup ---
            generateRandomMessage();
            runFullSimulation();

        }); // End DOMContentLoaded
    </script>
    <!-- **** END OF JAVASCRIPT **** -->

</body>
</html>